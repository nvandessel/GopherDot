package config

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// InitConfig scans the directory and interactively generates a configuration
// using standard input/output
func InitConfig(path string) error {
	return InitConfigWithIO(path, os.Stdin, os.Stdout)
}

// InitConfigWithIO allows specifying input/output for testing
func InitConfigWithIO(path string, in io.Reader, out io.Writer) error {
	absPath, err := filepath.Abs(path)
	if err != nil {
		return fmt.Errorf("failed to resolve path: %w", err)
	}

	// Create a single reader for the entire session
	reader := bufio.NewReader(in)

	configFile := filepath.Join(absPath, ConfigFileName)
	if _, err := os.Stat(configFile); err == nil {
		confirm, err := promptYesNo(reader, out, fmt.Sprintf("%s already exists. Overwrite?", ConfigFileName), false)
		if err != nil {
			return err
		}
		if !confirm {
			fmt.Fprintln(out, "Aborted.")
			return nil
		}
	}

	fmt.Fprintf(out, "ðŸ” Scanning %s for dotfiles...\n", absPath)
	configs, err := scanDirectory(absPath)
	if err != nil {
		return err
	}

	fmt.Fprintf(out, "Found %d potential config directories.\n\n", len(configs))

	// Collect Metadata
	meta := Metadata{
		Version: "1.0.0",
	}

	defaultName := filepath.Base(absPath)
	meta.Name = promptString(reader, out, "Project Name", defaultName)
	
	// Try to get git user/email if available, but keep it simple for now
	meta.Author = promptString(reader, out, "Author", os.Getenv("USER"))
	meta.Description = promptString(reader, out, "Description", "My personal dotfiles")
	meta.Repository = promptString(reader, out, "Repository URL", "")

	// Filter Configs
	var selectedConfigs []ConfigItem
	if len(configs) > 0 {
		fmt.Fprintln(out, "\nSelect configurations to manage:")
		for _, c := range configs {
			add, err := promptYesNo(reader, out, fmt.Sprintf("Add '%s'?", c.Name), true)
			if err != nil {
				return err
			}
			if add {
				c.Description = promptString(reader, out, fmt.Sprintf("  Description for %s", c.Name), fmt.Sprintf("%s configuration", c.Name))
				selectedConfigs = append(selectedConfigs, c)
			}
		}
	}

	// Create Config
	cfg := Config{
		SchemaVersion: "1.0",
		Metadata:      meta,
		Dependencies: Dependencies{
			Critical: []DependencyItem{
				{Name: "git", Binary: "git"},
				{Name: "stow", Binary: "stow"},
			},
		},
		Configs: ConfigGroups{
			Core: selectedConfigs,
		},
		MachineConfig: []MachinePrompt{}, // Initialize empty
	}

	// Generate YAML
	data, err := yaml.Marshal(&cfg)
	if err != nil {
		return fmt.Errorf("failed to generate YAML: %w", err)
	}

	// Add comments to the top
	content := fmt.Sprintf("# Generated by go4dot\n# Edit this file to customize your dotfiles management\n\n%s", string(data))

	if err := os.WriteFile(configFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Fprintf(out, "\nâœ… Successfully created %s\n", configFile)
	fmt.Fprintln(out, "run 'g4d install' to set up your dotfiles!")

	return nil
}

func scanDirectory(root string) ([]ConfigItem, error) {
	entries, err := os.ReadDir(root)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory: %w", err)
	}

	var items []ConfigItem
	ignored := map[string]bool{
		".git":          true,
		".github":       true,
		".idea":         true,
		".vscode":       true,
		"bin":           true,
		ConfigFileName:  true,
		"README.md":     true,
		"LICENSE":       true,
		"Makefile":      true,
		"go.mod":        true,
		"go.sum":        true,
	}

	for _, entry := range entries {
		name := entry.Name()
		if ignored[name] {
			continue
		}

		// Skip hidden files/dirs unless explicitly dotfiles
		if !entry.IsDir() {
			continue
		}

		items = append(items, ConfigItem{
			Name:        name,
			Path:        name,
			Description: fmt.Sprintf("%s configuration", name),
			Platforms:   []string{"linux", "macos"},
		})
	}

	return items, nil
}

func promptString(reader *bufio.Reader, out io.Writer, label, defaultValue string) string {
	prompt := label
	if defaultValue != "" {
		prompt = fmt.Sprintf("%s [%s]", label, defaultValue)
	}
	fmt.Fprint(out, prompt + ": ")
	
	text, _ := reader.ReadString('\n')
	text = strings.TrimSpace(text)
	
	if text == "" {
		return defaultValue
	}
	return text
}

func promptYesNo(reader *bufio.Reader, out io.Writer, label string, defaultYes bool) (bool, error) {
	choices := "Y/n"
	if !defaultYes {
		choices = "y/N"
	}
	
	fmt.Fprintf(out, "%s [%s]: ", label, choices)
	
	text, err := reader.ReadString('\n')
	if err != nil {
		return false, err
	}
	text = strings.TrimSpace(strings.ToLower(text))
	
	if text == "" {
		return defaultYes, nil
	}
	
	if text == "y" || text == "yes" {
		return true, nil
	}
	return false, nil
}
